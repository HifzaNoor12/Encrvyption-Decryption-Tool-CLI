def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

# 1. Additive Cipher
def additive_cipher_encrypt(plaintext, key):
    try:
        return ''.join([chr(((ord(char) - 65 + key) % 26) + 65) if char.isalpha() else char for char in plaintext.upper()])
    except Exception as e:
        return f"Error: {e}"

def additive_cipher_decrypt(ciphertext, key):
    try:
        return ''.join([chr(((ord(char) - 65 - key) % 26) + 65) if char.isalpha() else char for char in ciphertext.upper()])
    except Exception as e:
        return f"Error: {e}"

# 2. Multiplicative Cipher
def multiplicative_cipher_encrypt(plaintext, key):
    try:
        if gcd(key, 26) != 1:
            return "Error: Key is not coprime with 26. Please enter a valid key."
        return ''.join([chr(((ord(char) - 65) * key % 26) + 65) if char.isalpha() else char for char in plaintext.upper()])
    except Exception as e:
        return f"Error: {e}"

def multiplicative_cipher_decrypt(ciphertext, key):
    try:
        if gcd(key, 26) != 1:
            return "Error: Key is not coprime with 26. Please enter a valid key."
        inverse_key = pow(key, -1, 26)  # Find modular inverse of key
        return ''.join([chr(((ord(char) - 65) * inverse_key % 26) + 65) if char.isalpha() else char for char in ciphertext.upper()])
    except Exception as e:
        return f"Error: {e}"

# 3. Affine Cipher
def affine_cipher_encrypt(plaintext, a, b):
    try:
        if gcd(a, 26) != 1:
            return "Error: Key 'a' is not coprime with 26."
        return ''.join([chr(((a * (ord(char) - 65) + b) % 26) + 65) if char.isalpha() else char for char in plaintext.upper()])
    except Exception as e:
        return f"Error: {e}"

def affine_cipher_decrypt(ciphertext, a, b):
    try:
        inverse_a = pow(a, -1, 26)
        return ''.join([chr(((inverse_a * ((ord(char) - 65) - b)) % 26) + 65) if char.isalpha() else char for char in ciphertext.upper()])
    except Exception as e:
        return f"Error: {e}"

# 4. Monoalphabetic Substitution Cipher
def monoalphabetic_substitution_encrypt(plaintext, key_mapping):
    try:
        return ''.join([key_mapping.get(char, char) for char in plaintext.upper()])
    except Exception as e:
        return f"Error: {e}"

def monoalphabetic_substitution_decrypt(ciphertext, key_mapping):
    try:
        reverse_mapping = {v: k for k, v in key_mapping.items()}
        return ''.join([reverse_mapping.get(char, char) for char in ciphertext.upper()])
    except Exception as e:
        return f"Error: {e}"

# 5. Autokey Cipher
def autokey_cipher_encrypt(plaintext, keyword):
    try:
        keyword = (keyword + plaintext).upper()
        return ''.join([chr(((ord(plaintext[i]) - 65 + ord(keyword[i]) - 65) % 26) + 65) for i in range(len(plaintext))])
    except Exception as e:
        return f"Error: {e}"

def autokey_cipher_decrypt(ciphertext, keyword):
    try:
        decrypted = []
        keyword = keyword.upper()
        for i in range(len(ciphertext)):
            key_char = keyword[i] if i < len(keyword) else decrypted[i - len(keyword)]
            decrypted.append(chr(((ord(ciphertext[i]) - ord(key_char)) % 26) + 65))
        return ''.join(decrypted)
    except Exception as e:
        return f"Error: {e}"

# 6. Playfair Cipher
def create_playfair_matrix(key):
    alphabet = "ABCDEFGHIKLMNOPQRSTUVWXYZ"  # 'J' is omitted
    seen = set()
    matrix = []

    # Add characters from the key
    for char in key.upper():
        if char in alphabet and char not in seen:
            seen.add(char)
            matrix.append(char)

    # Fill in remaining characters
    for char in alphabet:
        if char not in seen:
            seen.add(char)
            matrix.append(char)

    return [matrix[i:i + 5] for i in range(0, 25, 5)]

def find_position(char, matrix):
    for row in range(5):
        for col in range(5):
            if matrix[row][col] == char:
                return row, col
    return None

def encrypt_digraph(digraph, matrix):
    row1, col1 = find_position(digraph[0], matrix)
    row2, col2 = find_position(digraph[1], matrix)

    if row1 == row2:
        return matrix[row1][(col1 + 1) % 5] + matrix[row2][(col2 + 1) % 5]
    elif col1 == col2:
        return matrix[(row1 + 1) % 5][col1] + matrix[(row2 + 1) % 5][col2]
    else:
        return matrix[row1][col2] + matrix[row2][col1]

def decrypt_digraph(digraph, matrix):
    row1, col1 = find_position(digraph[0], matrix)
    row2, col2 = find_position(digraph[1], matrix)

    if row1 == row2:
        return matrix[row1][(col1 - 1) % 5] + matrix[row2][(col2 - 1) % 5]
    elif col1 == col2:
        return matrix[(row1 - 1) % 5][col1] + matrix[(row2 - 1) % 5][col2]
    else:
        return matrix[row1][col2] + matrix[row2][col1]

def format_playfair_plaintext(plaintext):
    plaintext = plaintext.replace(" ", "").upper().replace("J", "I")
    formatted_text = ""

    i = 0
    while i < len(plaintext):
        formatted_text += plaintext[i]

        if i + 1 < len(plaintext):
            if plaintext[i] == plaintext[i + 1]:
                formatted_text += 'X'  # Bogus character for the repeated character
                i += 1
            else:
                formatted_text += plaintext[i + 1]  # Add the next character
                i += 2
        else:
            formatted_text += 'X'  # If odd length, add a bogus character
            i += 1

    return formatted_text

def playfair_cipher_encrypt(plaintext, key):
    matrix = create_playfair_matrix(key)
    formatted_plaintext = format_playfair_plaintext(plaintext)

    ciphertext = ""
    for i in range(0, len(formatted_plaintext), 2):
        digraph = formatted_plaintext[i:i + 2]
        ciphertext += encrypt_digraph(digraph, matrix)

    return ciphertext

def playfair_cipher_decrypt(ciphertext, key):
    matrix = create_playfair_matrix(key)

    plaintext = ""
    for i in range(0, len(ciphertext), 2):
        digraph = ciphertext[i:i + 2]
        decrypted = decrypt_digraph(digraph, matrix)
        
        # If 'X' is found, replace it with the preceding character
        if 'X' in decrypted:
            if decrypted[0] == 'X':
                plaintext += decrypted[1]  # Replace 'X' with the other char
            elif decrypted[1] == 'X':
                plaintext += decrypted[0]  # Replace 'X' with the other char
            else:
                plaintext += decrypted  # If no 'X', add as is
        else:
            plaintext += decrypted

    # Remove trailing 'X' if present
    if plaintext.endswith('X'):
        plaintext = plaintext[:-1]

    return plaintext
# 7. VigenÃ¨re Cipher
def vigenere_cipher_encrypt(plaintext, keyword):
    try:
        keyword = (keyword * (len(plaintext) // len(keyword) + 1))[:len(plaintext)].upper()
        return ''.join([chr(((ord(plaintext[i]) - 65) + (ord(keyword[i]) - 65)) % 26 + 65) for i in range(len(plaintext))])
    except Exception as e:
        return f"Error: {e}"

def vigenere_cipher_decrypt(ciphertext, keyword):
    try:
        keyword = (keyword * (len(ciphertext) // len(keyword) + 1))[:len(ciphertext)].upper()
        return ''.join([chr(((ord(ciphertext[i]) - 65) - (ord(keyword[i]) - 65)) % 26 + 65) for i in range(len(ciphertext))])
    except Exception as e:
        return f"Error: {e}"

# 8. Keyless Transposition Cipher
def keyless_transposition_encrypt(plaintext):
    try:
        n = 2  # Example with two columns
        return ''.join([plaintext[i::n] for i in range(n)])
    except Exception as e:
        return f"Error: {e}"

def keyless_transposition_decrypt(ciphertext):
    try:
        n = 2  # Example with two columns
        mid = len(ciphertext) // n
        return ''.join([ciphertext[i] for i in range(mid)] + [ciphertext[i] for i in range(mid, len(ciphertext))])
    except Exception as e:
        return f"Error: {e}"

# 9. Keyed Transposition Cipher
def keyed_transposition_encrypt(plaintext, key):
    try:
        key_order = sorted(range(len(key)), key=lambda k: key[k])
        padded_plaintext = plaintext + ' ' * (len(key) - len(plaintext) % len(key))  # Padding with spaces
        columns = ['' for _ in key]
        
        for i in range(len(padded_plaintext)):
            columns[i % len(key)] += padded_plaintext[i]
        
        return ''.join(columns[i] for i in key_order)
    except Exception as e:
        return f"Error: {e}"

def keyed_transposition_decrypt(ciphertext, key):
    try:
        key_order = sorted(range(len(key)), key=lambda k: key[k])
        n = len(key)
        rows = [ciphertext[i:i + len(ciphertext) // n] for i in range(0, len(ciphertext), len(ciphertext) // n)]
        columns = ['' for _ in key]
        
        for i in key_order:
            columns[i] = rows.pop(0)
        
        return ''.join(''.join(col) for col in zip(*columns)).replace(' ', '')
    except Exception as e:
        return f"Error: {e}"

# 10. Combined Keyless and Keyed Transposition
def combined_transposition_encrypt(plaintext, key):
    try:
        # First apply Keyless Transposition
        intermediate = keyless_transposition_encrypt(plaintext)
        # Then apply Keyed Transposition
        return keyed_transposition_encrypt(intermediate, key)
    except Exception as e:
        return f"Error: {e}"

def combined_transposition_decrypt(ciphertext, key):
    try:
        # First apply Keyed Transposition
        intermediate = keyed_transposition_decrypt(ciphertext, key)
        # Then apply Keyless Transposition
        return keyless_transposition_decrypt(intermediate)
    except Exception as e:
        return f"Error: {e}"

# 11. Double Transposition Cipher
def double_transposition_encrypt(plaintext, key1, key2):
    try:
        # First apply Keyed Transposition
        first_pass = keyed_transposition_encrypt(plaintext, key1)
        # Then apply another Keyed Transposition
        return keyed_transposition_encrypt(first_pass, key2)
    except Exception as e:
        return f"Error: {e}"

def double_transposition_decrypt(ciphertext, key1, key2):
    try:
        # First apply reverse Keyed Transposition
        first_pass = keyed_transposition_decrypt(ciphertext, key2)
        # Then apply reverse Keyed Transposition
        return keyed_transposition_decrypt(first_pass, key1)
    except Exception as e:
        return f"Error: {e}"


